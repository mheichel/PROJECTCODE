import pandas as pd
import plotly.graph_objs as go
import plotly.subplots as sp
import glob
import numpy as np
import dash
from dash import dcc, html

# Color schemes
actual_color = '#0E5E1E'
forecast_colors = ['red', 'orangered', 'orange', 'darkkhaki', 'turquoise', 'blue', 'indigo', '#B026FF', 'darkgray', 'white']

# Functions
def load_files(file_pattern):
    files = glob.glob(file_pattern)
    data = {}
    for file in files:
        df = pd.read_csv(file, low_memory=False)
        df['Date'] = pd.to_datetime(df['Date'])
        df = df.sort_values(by=['API 14', 'Date'])
        df['Normalized Month'] = df.groupby('API 14').cumcount() + 1
        month_count = int(file.split('_')[2])
        data[month_count] = df
    return data

def calculate_cumulative(df):
    df['Cumulative Production'] = df.groupby('API 14')['Oil Production (BBL/M)'].cumsum()
    df['Cumulative Forecast'] = df.groupby('API 14')['Oil Forecast (BBL/M)'].cumsum()
    return df

def filter_wells(data_dict):
    filtered_data = {}
    for month, df in data_dict.items():
        if month == 60:
            api_60 = df['API 14'].unique()
        if month == 6:
            api_6 = df['API 14'].unique()
    valid_apis = set(api_6).intersection(api_60)
    for month, df in data_dict.items():
        df = df[df['API 14'].isin(valid_apis)]
        filtered_data[month] = df
    return filtered_data

def calculate_p90(data_dict):
    differences = []
    for api in data_dict[60]['API 14'].unique():
        cum_6 = data_dict[6].loc[data_dict[6]['API 14'] == api, 'Cumulative Forecast'].iloc[-1]
        cum_60 = data_dict[60].loc[data_dict[60]['API 14'] == api, 'Cumulative Forecast'].iloc[-1]
        if cum_60 != 0:
            abs_diff = abs(cum_60 - cum_6)
            differences.append((api, abs_diff))
    df_differences = pd.DataFrame(differences, columns=['API 14', 'Abs Difference'])
    perct90 = df_differences[df_differences['API 14'] == 30025451330000]['Abs Difference']
    return [30025451330000]

def calculate_percent_error(data_dict):
    percent_errors = {}
    for month, df in data_dict.items():
        if month == 60:
            cum_60 = df.groupby('API 14')['Cumulative Forecast'].last().reset_index()
            cum_60 = cum_60.rename(columns={'Cumulative Forecast': 'Cumulative Forecast 60'})
        else:
            cum = df.groupby('API 14')['Cumulative Forecast'].last().reset_index()
            cum_60 = cum_60.merge(cum, on='API 14', suffixes=('', f'_{month}'))
            cum_60[f'Percent Error {month}'] = ((cum_60[f'Cumulative Forecast_{month}'] - cum_60['Cumulative Forecast 60']) / cum_60['Cumulative Forecast 60']) * 100
        percent_errors[month] = cum_60
    return percent_errors

def plot_percent_error(percent_errors, p90_api, line_colors, line_widths, current_month):
    percent_error_graph = go.Figure()
    for api in p90_api:
        error_data = []
        for month in range(6, current_month + 1, 6):
            df = percent_errors[month]
            well_data = df[df['API 14'] == api].reset_index()
            error_data.append(well_data[f'Percent Error {month}'].iloc[0])
            percent_error_graph.add_trace(go.Scatter(
                x=[month],
                y=[well_data[f'Percent Error {month}'].iloc[0]],
                mode='markers',
                marker=dict(color=line_colors[f'{month} Month Cum'], size=10, line=dict(color='white', width=2)),
                name=f'{month} Month Percent Error',
                showlegend=False
            ))
        percent_error_graph.add_trace(go.Scatter(
            x=list(range(6, current_month + 1, 6)),
            y=error_data,
            mode='lines',
            line=dict(color=line_colors['Cum Production'], width=line_widths['Cum Production']),
            name='Percent Error',
            showlegend=False,
            text=['Percent Error'] * len(error_data),
            textposition="top center"
        ))
    percent_error_graph.update_layout(
        title=f"Percent Error | API: {p90_api}",
        yaxis_title='Percent Error (%)',
        template='plotly_dark',
        hovermode='x',
        font=dict(color='white')
    )
    percent_error_graph.update_xaxes(tickfont=dict(color='white'), titlefont=dict(color='white'))
    percent_error_graph.update_yaxes(tickfont=dict(color='white'), titlefont=dict(color='white'))
    return percent_error_graph

def combine_plots(scatter, percent_error_graph, p90_api):
    fig = sp.make_subplots(rows=2, cols=1, vertical_spacing=0.05, subplot_titles=('Production Data [BBL/M]', 'Percent Error [%]'))
    fig.update_yaxes(type='log', gridcolor='rgba(135, 135, 135, 0.5)', tickcolor='white', linecolor='white', tickwidth=0.01, gridwidth=0.01)
    fig.update_xaxes(gridcolor='rgba(135, 135, 135, 0.5)', tickcolor='white', linecolor='white', gridwidth=0.01, tickwidth=0.01)
    fig.update_xaxes(range=[1, 62])
    for trace in scatter.data:
        fig.add_trace(trace, row=1, col=1)
    fig.update_yaxes(range=[np.log10(1000), np.log10(31000)], row=1, col=1)
    for trace in percent_error_graph.data:
        fig.add_trace(trace, row=2, col=1)
    fig.update_yaxes(range=[-100, 100], row=2, col=1)
    fig.update_layout(
        height=1100,
        width=900,
        hovermode='x',
        paper_bgcolor="#242426",
        plot_bgcolor="#242426",
        title_font=dict(family='EMPrint', color='white'),
        margin=dict(l=0.25, r=0.25, t=0.225, b=0.3)
    )
    fig.update_annotations(font=dict(color='white', family='EMPrint'))
    fig.update_xaxes(tickfont=dict(color='white'), titlefont=dict(color='white'))
    fig.update_yaxes(tickfont=dict(color='white'), titlefont=dict(color='white'))
    fig.update_layout(legend_font=dict(color='white'))
    return fig

file_pattern = 'Delaware_NM_*_Months_Combined_Monthly.csv'
data_dict = load_files(file_pattern)
for month in data_dict:
    data_dict[month] = calculate_cumulative(data_dict[month])
filtered_data_dict = filter_wells(data_dict)
p90_api = calculate_p90(filtered_data_dict)
percent_errors = calculate_percent_error(filtered_data_dict)

# Default line colors and widths
line_colors = {
    'Production': '#0E5E1E',
    'Cum Production': '#0E5E1E',
    '6 Month Forecast': 'red',
    '12 Month Forecast': 'orangered',
    '18 Month Forecast': 'orange',
    '24 Month Forecast': 'darkkhaki',
    '30 Month Forecast': 'turquoise',
    '36 Month Forecast': 'blue',
    '42 Month Forecast': 'indigo',
    '48 Month Forecast': '#B026FF',
    '54 Month Forecast': 'darkgray',
    '60 Month Forecast': 'white',
    '6 Month Cum': 'red',
    '12 Month Cum': 'orangered',
    '18 Month Cum': 'orange',
    '24 Month Cum': 'darkkhaki',
    '30 Month Cum': 'turquoise',
    '36 Month Cum': 'blue',
    '42 Month Cum': 'indigo',
    '48 Month Cum': '#B026FF',
    '54 Month Cum': 'darkgray',
    '60 Month Cum': 'white',
}
line_widths = {key: 3 for key in line_colors.keys()}

scatter = plot_production(filtered_data_dict, p90_api, line_colors, line_widths, 6)
percent_error_graph = plot_percent_error(percent_errors, p90_api, line_colors, line_widths, 6)
combine_plots(scatter, percent_error_graph, p90_api).show()

# Dash app for interactive plot
app = dash.Dash(__name__)

# Initialize the application layout
app.layout = html.Div([
    dcc.Graph(id='scatter-plot'),
    dcc.Slider(
        id='month-slider',
        min=6,
        max=60,
        value=6,
        marks={i: str(i) for i in range(6, 61, 6)},
        step=6
    ),
    html.Button('Next', id='next-button', n_clicks=0),
    html.Button('Previous', id='previous-button', n_clicks=0)
])

@app.callback(
    dash.dependencies.Output('scatter-plot', 'figure'),
    [dash.dependencies.Input('next-button', 'n_clicks'),
     dash.dependencies.Input('previous-button', 'n_clicks'),
     dash.dependencies.Input('scatter-plot', 'relayoutData')],
    [dash.dependencies.State('month-slider', 'value')]
)
def update_plot(next_clicks, previous_clicks, relayout_data, current_month):
    ctx = dash.callback_context
    if not ctx.triggered:
        button_id = 'No clicks yet'
    else:
        button_id = ctx.triggered[0]['prop_id'].split('.')[0]
   
    if button_id == 'next-button':
        current_month = min(current_month + 6, 60)
    elif button_id == 'previous-button':
        current_month = max(current_month - 6, 6)
   
    scatter = plot_production(filtered_data_dict, p90_api, line_colors, line_widths, current_month)
    percent_error_graph = plot_percent_error(percent_errors, p90_api, line_colors, line_widths, current_month)
    fig = combine_plots(scatter, percent_error_graph, p90_api)

    if relayout_data and 'xaxis.range[0]' in relayout_data:
        fig.update_layout(
            xaxis=dict(range=[relayout_data['xaxis.range[0]'], relayout_data['xaxis.range[1]']]),
            yaxis=dict(range=[relayout_data['yaxis.range[0]'], relayout_data['yaxis.range[1]']])
        )

    return fig

@app.callback(
    dash.dependencies.Output('month-slider', 'value'),
    [dash.dependencies.Input('next-button', 'n_clicks'),
     dash.dependencies.Input('previous-button', 'n_clicks')],
    [dash.dependencies.State('month-slider', 'value')]
)
def update_slider(next_clicks, previous_clicks, current_month):
    ctx = dash.callback_context
    if not ctx.triggered:
        button_id = 'No clicks yet'
    else:
        button_id = ctx.triggered[0]['prop_id'].split('.')[0]
   
    if button_id == 'next-button':
        current_month = min(current_month + 6, 60)
    elif button_id == 'previous-button':
        current_month = max(current_month - 6, 6)
   
    return current_month

if __name__ == '__main__':
    app.run_server(debug=True)
