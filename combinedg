<!DOCTYPE html>
<html>
<head>
    <title>Combined Output</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-omnivore/0.3.4/leaflet-omnivore.min.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
        }
        #map {
            width: 50%;
            height: 100%;
            float: left;
        }
        #plots {
            width: 50%;
            height: 100%;
            float: left;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 60px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div id="controls">
        <select id="layer-select" onchange="updateMap()">
            <optgroup label="Sections">
                <option value="1_avg_6_months">6 Months</option>
                <option value="1_avg_12_months">12 Months</option>
                <!-- Add other options as needed -->
            </optgroup>
            <optgroup label="Townships">
                <option value="2_avg_6_months">6 Months</option>
                <option value="2_avg_12_months">12 Months</option>
                <!-- Add other options as needed -->
            </optgroup>
        </select>
    </div>
    <div id="map"></div>
    <div class="legend" id="legend"></div>
    <div id="plots">
        <div id="scatter_plot"></div>
        <div id="cum_graph"></div>
    </div>
    <script>
        var mean_latitude = 32.7767; // Example latitude
        var mean_longitude = -96.7970; // Example longitude

        var map = L.map('map').setView([mean_latitude, mean_longitude], 10);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 18,
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        var colormaps = {};
        var colormaps2 = {};

        var data_dict = {};

        // Function to load CSV files and process them
        function loadCSVFiles(fileNames, callback) {
            var filesProcessed = 0;
            fileNames.forEach(function(fileName) {
                Papa.parse(fileName, {
                    download: true,
                    header: true,
                    complete: function(results) {
                        var month = parseInt(fileName.match(/_(\d+)_Months_/)[1]);
                        results.data.forEach(function(row) {
                            row['Date'] = new Date(row['Date']);
                            row['Normalized Month'] = parseInt(row['Normalized Month']);
                            row['Oil Production (BBL/M)'] = parseFloat(row['Oil Production (BBL/M)']);
                            row['Oil Forecast (BBL/M)'] = parseFloat(row['Oil Forecast (BBL/M)']);
                        });
                        data_dict[month] = results.data;
                        filesProcessed++;
                        if (filesProcessed === fileNames.length) {
                            callback();
                        }
                    }
                });
            });
        }

        // Function to calculate cumulative production and forecast
        function calculateCumulative(data) {
            var apiGroups = data.reduce(function(groups, row) {
                var api = row['API 14'];
                if (!groups[api]) {
                    groups[api] = [];
                }
                groups[api].push(row);
                return groups;
            }, {});

            for (var api in apiGroups) {
                var cumulativeProduction = 0;
                var cumulativeForecast = 0;
                apiGroups[api].forEach(function(row) {
                    cumulativeProduction += row['Oil Production (BBL/M)'];
                    cumulativeForecast += row['Oil Forecast (BBL/M)'];
                    row['Cumulative Production'] = cumulativeProduction;
                    row['Cumulative Forecast'] = cumulativeForecast;
                });
            }
        }

        // Function to plot production data
        function plotProduction(data_dict, api) {
            var scatter = {
                data: [],
                layout: {
                    title: 'Production Data | API: ' + api,
                    xaxis: { title: 'Normalized Month' },
                    yaxis: { title: 'Production' },
                    template: 'plotly_dark',
                    hovermode: 'x'
                }
            };
            for (var month in data_dict) {
                var well_data = data_dict[month].filter(function(row) { return row['API 14'] == api; });
                scatter.data.push({
                    x: well_data.map(row => row['Normalized Month']),
                    y: well_data.map(row => row['Oil Production (BBL/M)']),
                    mode: 'lines',
                    name: month + ' Production'
                });
                scatter.data.push({
                    x: well_data.map(row => row['Normalized Month']),
                    y: well_data.map(row => row['Oil Forecast (BBL/M)']),
                    mode: 'lines',
                    line: { dash: 'dot' },
                    name: month + ' Forecast'
                });
            }
            return scatter;
        }

        // Function to plot cumulative production data
        function plotCumulativeProduction(data_dict, api) {
            var cum_graph = {
                data: [],
                layout: {
                    title: 'Cumulative Production | API: ' + api,
                    xaxis: { title: 'Normalized Month' },
                    yaxis: { title: 'Cumulative Production' },
                    template: 'plotly_dark',
                    hovermode: 'x'
                }
            };
            for (var month in data_dict) {
                var well_data = data_dict[month].filter(function(row) { return row['API 14'] == api; });
                var cumulativeProduction = 0;
                var cumulativeForecast = 0;
                well_data.forEach(function(row) {
                    cumulativeProduction += row['Oil Production (BBL/M)'];
                    cumulativeForecast += row['Oil Forecast (BBL/M)'];
                    row['Cumulative Production'] = cumulativeProduction;
                    row['Cumulative Forecast'] = cumulativeForecast;
                });
                cum_graph.data.push({
                    x: well_data.map(row => row['Normalized Month']),
                    y: well_data.map(row => row['Cumulative Production']),
                    mode: 'lines',
                    name: month + ' Cum Production'
                });
                cum_graph.data.push({
                    x: well_data.map(row => row['Normalized Month']),
                    y: well_data.map(row => row['Cumulative Forecast']),
                    mode: 'lines',
                    line: { dash: 'dot' },
                    name: month + ' Cum Forecast'
                });
            }
            return cum_graph;
        }

        // Function to update plots based on API
        function updatePlots(api) {
            var scatter_data = plotProduction(data_dict, api);
            var cum_graph_data = plotCumulativeProduction(data_dict, api);

            Plotly.react('scatter_plot', scatter_data.data, scatter_data.layout);
            Plotly.react('cum_graph', cum_graph_data.data, cum_graph_data.layout);
        }

        // Function to update legend
        function updateLegend(colormap) {
            var legend = d3.select('#legend');
            legend.html('<h4>EUR/PLL [BBL/FT]</h4>');
            var legendScale = d3.scaleLinear()
                .domain([0, 90])
                .range([0, 300]);

            var legendAxis = d3.axisBottom(legendScale)
                .ticks(5)
                .tickFormat(d3.format(".2f"));

            var svg = legend.append('svg')
                .attr('width', 320)
                .attr('height', 50);

            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', 'translate(10,30)')
                .call(legendAxis);

            var gradient = svg.append('defs')
                .append('linearGradient')
                .attr('id', 'gradient')
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '100%')
                .attr('y2', '0%');

            [15, 30, 45, 60, 75, 90].forEach(function(d, i) {
                gradient.append('stop')
                    .attr('offset', (i / 5 * 100) + '%')
                    .attr('stop-color', colormap(d));
            });

            svg.append('rect')
                .attr('width', 300)
                .attr('height', 10)
                .attr('x', 10)
                .attr('y', 20)
                .style('fill', 'url(#gradient)');
        }

        // Function to update map based on selected layer
        function updateMap() {
            var selectedLayer = document.getElementById('layer-select').value;
            if (currentLayer) {
                map.removeLayer(currentLayer);
            }
            currentLayer = window['layer_' + selectedLayer];
            if (currentLayer) {
                currentLayer.addTo(map);
                var colormapSet = selectedLayer.startsWith("1_") ? colormaps : colormaps2;
                updateLegend(colormapSet[selectedLayer.split('_')[1]]);
            }
        }

        var currentLayer;

        function loadGeoJSONFiles(geojsonFiles, callback) {
            var filesProcessed = 0;
            geojsonFiles.forEach(function(file) {
                fetch(file)
                    .then(response => response.json())
                    .then(data => {
                        var avg_col_name = file.match(/([^\/]+)(?=\.\w+$)/)[0]; // Extract filename without extension
                        colormaps[avg_col_name] = d3.scaleThreshold()
                            .domain([15, 30, 45, 60, 75, 90])
                            .range(["white", "blue", "green", "yellow", "orange", "red"]);

                        colormaps2[avg_col_name] = d3.scaleThreshold()
                            .domain([15, 30, 45, 60, 75, 90])
                            .range(["white", "blue", "green", "yellow", "orange", "red"]);

                        function style(feature) {
                            return {
                                fillColor: colormaps[avg_col_name](feature.properties[avg_col_name]),
                                color: 'black',
                                weight: 0.5,
                                fillOpacity: 0.7
                            };
                        }

                        function style2(feature) {
                            return {
                                fillColor: colormaps2[avg_col_name](feature.properties[avg_col_name]),
                                color: 'black',
                                weight: 0.5,
                                fillOpacity: 0.7
                            };
                        }

                        window['layer_1_' + avg_col_name] = L.geoJson(data, {
                            style: style,
                            onEachFeature: function (feature, layer) {
                                layer.bindPopup('EUR (' + avg_col_name + '): ' + feature.properties[avg_col_name].toFixed(2));
                                layer.on('click', function(e) {
                                    updatePlots(feature.properties['API 14']);
                                });
                            }
                        });

                        window['layer_2_' + avg_col_name] = L.geoJson(data, {
                            style: style2,
                            onEachFeature: function (feature, layer) {
                                layer.bindPopup('EUR (' + avg_col_name + '): ' + feature.properties[avg_col_name].toFixed(2));
                                layer.on('click', function(e) {
                                    updatePlots(feature.properties['API 14']);
                                });
                            }
                        });

                        filesProcessed++;
                        if (filesProcessed === geojsonFiles.length) {
                            callback();
                        }
                    });
            });
        }

        // Load data and initialize plots
        var fileNames = ['Delaware_NM_6_Months_Combined_Monthly.csv', 'Delaware_NM_12_Months_Combined_Monthly.csv']; // Add other files as needed
        var geojsonFiles = ['PLSSFirstDivision.geojson', 'PLSSTownship.geojson']; // Add other geojson files as needed

        loadCSVFiles(fileNames, function() {
            for (var month in data_dict) {
                calculateCumulative(data_dict[month]);
            }
            loadGeoJSONFiles(geojsonFiles, function() {
                // Initialize the plots with the provided API
                currentLayer = window['layer_1_avg_6_months'];
                currentLayer.addTo(map);
                updatePlots(30025428950000);
            });
        });

    </script>
</body>
</html>
