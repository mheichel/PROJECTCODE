import pandas as pd
import geopandas as gpd
import numpy as np
from shapely.geometry import Point
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import dash_leaflet as dl
import json

# Load the wells_df
columns = [
    'API 14', 'Surface Longitude', 'Surface Latitude',
    'EUR/PLL (BBL/FT) 6 Months', 'EUR/PLL (BBL/FT) 12 Months', 'EUR/PLL (BBL/FT) 18 Months',
    'EUR/PLL (BBL/FT) 24 Months', 'EUR/PLL (BBL/FT) 30 Months', 'EUR/PLL (BBL/FT) 36 Months',
    'EUR/PLL (BBL/FT) 42 Months', 'EUR/PLL (BBL/FT) 48 Months', 'EUR/PLL (BBL/FT) 54 Months',
    'EUR/PLL (BBL/FT) 60 Months', 'MyIntervalPlus', 'MyPerfInterval', 'FirstProdYear'
]

wells_df = pd.read_csv('AllWellsNoError.csv', usecols=columns)
wells_df = wells_df.rename(columns={'Surface Longitude': 'longitude', 'Surface Latitude': 'latitude'})
wells_df = wells_df[wells_df['latitude'] > 0.1]

for col in columns[3:13]:
    wells_df = wells_df[wells_df[col] > 0.1]
    wells_df = wells_df[wells_df[col] < np.nanpercentile(wells_df[col], 95)]

wells_df = wells_df.reset_index()

# Calculate mean latitude and longitude
mean_latitude = wells_df['latitude'].mean()
mean_longitude = wells_df['longitude'].mean()

# Convert well data to GeoDataFrame
geometry = [Point(xy) for xy in zip(wells_df['longitude'], wells_df['latitude'])]
geo_data = gpd.GeoDataFrame(wells_df, geometry=geometry)

# Set the CRS to WGS84 (EPSG:4326)
geo_data.set_crs(epsg=4326, inplace=True)

# Load the township boundaries shapefile
shape_data = gpd.read_file('PLSSFirstDivision.geojson')  # Replace with your shapefile path

# Ensure the CRS for the township boundaries is set to WGS84
shape_data.to_crs(epsg=4326, inplace=True)

# Spatial join to assign points to township polygons
joined = gpd.sjoin(geo_data, shape_data, how='left', op='within')

# Calculate average values for each township polygon
avg_col_names = []

for col in columns[3:13]:
    months = col.split()[2]
    avg_col_name = f'avg_{months}_months'
    shape_data[avg_col_name] = joined.groupby('index_right')[col].mean()
    avg_col_names.append(avg_col_name)

# Drop sections where all the average values are 0
shape_data = shape_data[(shape_data[avg_col_names] > 0).any(axis=1)]

# Create GeoJSON data for the first dataset
geojson1 = json.loads(shape_data.to_json())

# Load the second shapefile
shape_data2 = gpd.read_file('PLSSTownship.geojson')  # Replace with your second shapefile path
shape_data2.set_crs(epsg=4326, inplace=True)

# Spatial join to assign points to township polygons for the second shapefile
joined2 = gpd.sjoin(geo_data, shape_data2, how='left', op='within')

avg_col_names = []

for col in columns[3:13]:
    months = col.split()[2]
    avg_col_name = f'avg_{months}_months'
    shape_data2[avg_col_name] = joined2.groupby('index_right')[col].mean()
    avg_col_names.append(avg_col_name)

# Drop sections where all the average values are 0 for the second shapefile
shape_data2 = shape_data2[(shape_data2[avg_col_names] > 0).any(axis=1)]

# Create GeoJSON data for the second dataset
geojson2 = json.loads(shape_data2.to_json())

# Generate the HTML template
def generate_html_template(mean_latitude, mean_longitude, geojson1, geojson2):
    html_template = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>Dynamic Map</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
        <style>
            html, body {{
                height: 100%;
                margin: 0;
            }}
            #map {{
                width: 100%;
                height: 100%;
            }}
            #controls {{
                position: absolute;
                top: 10px;
                left: 50px;
                z-index: 1000;
                background: white;
                padding: 10px;
                border-radius: 5px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            }}
        </style>
        <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
        <script src="https://d3js.org/d3.v5.min.js"></script>
    </head>
    <body>
        <div id="controls">
            <select id="shapefile-select" onchange="updateMap()">
                <option value="geojson1">First Shapefile</option>
                <option value="geojson2">Second Shapefile</option>
            </select>
            <select id="intervals-select" multiple onchange="updateMap()">
                {''.join([f'<option value="{interval}">{interval}</option>' for interval in wells_df['MyIntervalPlus'].unique()])}
            </select>
            <select id="pllintervals-select" multiple onchange="updateMap()">
                {''.join([f'<option value="{interval}">{interval}</option>' for interval in wells_df['MyPerfInterval'].unique()])}
            </select>
            <select id="vintages-select" multiple onchange="updateMap()">
                {''.join([f'<option value="{vintage}">{vintage}</option>' for vintage in wells_df['FirstProdYear'].unique()])}
            </select>
        </div>
        <div id="map"></div>
        <script>
            var map = L.map('map').setView([{mean_latitude}, {mean_longitude}], 10);

            L.tileLayer('https://{{s}}.tile.openstreetmap.org/{{z}}/{{x}}/{{y}}.png', {{
                maxZoom: 18,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }}).addTo(map);

            var geojson1 = {json.dumps(geojson1)};
            var geojson2 = {json.dumps(geojson2)};

            var currentLayer = L.geoJSON(geojson1).addTo(map);

            function updateMap() {{
                var selectedShapefile = document.getElementById('shapefile-select').value;
                var selectedIntervals = Array.from(document.getElementById('intervals-select').selectedOptions).map(option => option.value);
                var selectedPLLIntervals = Array.from(document.getElementById('pllintervals-select').selectedOptions).map(option => option.value);
                var selectedVintages = Array.from(document.getElementById('vintages-select').selectedOptions).map(option => option.value);

                var geojsonData = selectedShapefile === 'geojson1' ? geojson1 : geojson2;
                var filteredFeatures = geojsonData.features.filter(feature => {{
                    var properties = feature.properties;
                    return (selectedIntervals.length === 0 || selectedIntervals.includes(properties.MyIntervalPlus)) &&
                           (selectedPLLIntervals.length === 0 || selectedPLLIntervals.includes(properties.MyPerfInterval)) &&
                           (selectedVintages.length === 0 || selectedVintages.includes(properties.FirstProdYear));
                }});

                if (currentLayer) {{
                    map.removeLayer(currentLayer);
                }}
                currentLayer = L.geoJSON({{'type': 'FeatureCollection', 'features': filteredFeatures}}).addTo(map);
            }}
        </script>
    </body>
    </html>
    """

    with open('dynamic_map.html', 'w') as f:
        f.write(html_template)

    print("HTML file created successfully: dynamic_map.html")

# Generate the HTML template before running the Dash app
generate_html_template(mean_latitude, mean_longitude, geojson1, geojson2)

# Dash app setup
app = dash.Dash(__name__)

app.layout = html.Div([
    html.H1("Well Data Map"),
    dcc.Dropdown(
        id='intervals-dropdown',
        options=[{'label': interval, 'value': interval} for interval in wells_df['MyIntervalPlus'].unique()],
        multi=True,
        placeholder="Select Intervals"
    ),
    dcc.Dropdown(
        id='pllintervals-dropdown',
        options=[{'label': interval, 'value': interval} for interval in wells_df['MyPerfInterval'].unique()],
        multi=True,
        placeholder="Select PLL Intervals"
    ),
    dcc.Dropdown(
        id='vintages-dropdown',
        options=[{'label': vintage, 'value': vintage} for vintage in wells_df['FirstProdYear'].unique()],
        multi=True,
        placeholder="Select Vintages"
    ),
    dcc.Dropdown(
        id='shapefile-dropdown',
        options=[
            {'label': 'First Shapefile', 'value': 'geojson1'},
            {'label': 'Second Shapefile', 'value': 'geojson2'}
        ],
        value='geojson1',
        placeholder="Select Shapefile"
    ),
    dl.Map(center=[mean_latitude, mean_longitude], zoom=10, children=[
        dl.TileLayer(),
        dl.GeoJSON(id='geojson')
    ], style={'width': '100%', 'height': '80vh', 'margin': "auto", "display": "block"})
])

@app.callback(
    Output('geojson', 'data'),
    [Input('shapefile-dropdown', 'value'),
     Input('intervals-dropdown', 'value'),
     Input('pllintervals-dropdown', 'value'),
     Input('vintages-dropdown', 'value')]
)
def update_map(selected_shapefile, selected_intervals, selected_pllintervals, selected_vintages):
    if selected_shapefile == 'geojson1':
        geojson_data = geojson1
    else:
        geojson_data = geojson2

    filtered_features = []
    for feature in geojson_data['features']:
        properties = feature['properties']
        if (selected_intervals is None or properties['MyIntervalPlus'] in selected_intervals) and \
           (selected_pllintervals is None or properties['MyPerfInterval'] in selected_pllintervals) and \
           (selected_vintages is None or properties['FirstProdYear'] in selected_vintages):
            filtered_features.append(feature)

    filtered_geojson = {'type': 'FeatureCollection', 'features': filtered_features}
    return filtered_geojson

if __name__ == '__main__':
    app.run_server(debug=True)
