import pandas as pd
import geopandas as gpd
import numpy as np
from shapely.geometry import Point
import branca.colormap as cm
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import plotly.express as px

# Load the wells_df
columns = [
    'API 14', 'Surface Longitude', 'Surface Latitude',
    'EUR/PLL (BBL/FT) 6 Months', 'EUR/PLL (BBL/FT) 12 Months', 'EUR/PLL (BBL/FT) 18 Months',
    'EUR/PLL (BBL/FT) 24 Months', 'EUR/PLL (BBL/FT) 30 Months', 'EUR/PLL (BBL/FT) 36 Months',
    'EUR/PLL (BBL/FT) 42 Months', 'EUR/PLL (BBL/FT) 48 Months', 'EUR/PLL (BBL/FT) 54 Months',
    'EUR/PLL (BBL/FT) 60 Months', 'MyIntervalPlus', 'MyPerfInterval', 'FirstProdYear'
]

wells_df = pd.read_csv('AllWellsNoError.csv', usecols=columns)
wells_df = wells_df.rename(columns={'Surface Longitude': 'longitude', 'Surface Latitude': 'latitude'})
wells_df = wells_df[wells_df['latitude'] > 0.1]

for col in columns[3:13]:
    wells_df = wells_df[wells_df[col] > 0.1]
    wells_df = wells_df[wells_df[col] < np.nanpercentile(wells_df[col], 95)]

wells_df = wells_df.reset_index()

# Calculate mean latitude and longitude
mean_latitude = wells_df['latitude'].mean()
mean_longitude = wells_df['longitude'].mean()

# Convert well data to GeoDataFrame
geometry = [Point(xy) for xy in zip(wells_df['longitude'], wells_df['latitude'])]
geo_data = gpd.GeoDataFrame(wells_df, geometry=geometry)

# Set the CRS to WGS84 (EPSG:4326)
geo_data.set_crs(epsg=4326, inplace=True)

# Load the township boundaries shapefile
shape_data = gpd.read_file('PLSSFirstDivision.geojson')  # Replace with your shapefile path

# Ensure the CRS for the township boundaries is set to WGS84
shape_data.to_crs(epsg=4326, inplace=True)

# Spatial join to assign points to township polygons
joined = gpd.sjoin(geo_data, shape_data, how='left', op='within')

# Calculate average values for each township polygon
avg_col_names = []

for col in columns[3:13]:
    months = col.split()[2]
    avg_col_name = f'avg_{months}_months'
    shape_data[avg_col_name] = joined.groupby('index_right')[col].mean()
    avg_col_names.append(avg_col_name)

# Drop sections where all the average values are 0
shape_data = shape_data[(shape_data[avg_col_names] > 0).any(axis=1)]

# Create colormaps for each time period
colormaps = {}

for col in avg_col_names:
    months = col[4]
    avg_col_name = col
    colormaps[avg_col_name] = cm.LinearColormap(colors=['blue', 'green', 'yellow', 'orange', 'red'],
                                                vmin=shape_data[avg_col_name].min(),
                                                vmax=150,
                                                caption=f'EUR Value ({col})')

# Create GeoJSON data for each dataset
geojson_data = {}

for col in avg_col_names:
    months = col
    avg_col_name = col
    geojson_data[avg_col_name] = shape_data[['geometry', avg_col_name]].to_json()

# Load the second shapefile
shape_data2 = gpd.read_file('PLSSTownship.geojson')  # Replace with your second shapefile path
shape_data2.set_crs(epsg=4326, inplace=True)

# Spatial join to assign points to township polygons for the second shapefile
joined2 = gpd.sjoin(geo_data, shape_data2, how='left', op='within')

avg_col_names = []

for col in columns[3:13]:
    months = col.split()[2]
    avg_col_name = f'avg_{months}_months'
    shape_data2[avg_col_name] = joined2.groupby('index_right')[col].mean()
    avg_col_names.append(avg_col_name)

# Drop sections where all the average values are 0 for the second shapefile
shape_data2 = shape_data2[(shape_data2[avg_col_names] > 0).any(axis=1)]

# Create colormaps and GeoJSON data for the second shapefile
colormaps2 = {}
geojson_data2 = {}

for col in avg_col_names:
    months = col
    avg_col_name = f'{col}'
    colormaps2[avg_col_name] = cm.LinearColormap(colors=['blue', 'green', 'yellow', 'orange', 'red'],
                                                 vmin=shape_data2[avg_col_name].min(),
                                                 vmax=150,
                                                 caption=f'EUR Value ({months})')
    geojson_data2[avg_col_name] = shape_data2[['geometry', avg_col_name]].to_json()

# Dash app setup
app = dash.Dash(__name__)

app.layout = html.Div([
    html.H1("Well Data Heatmap"),
    dcc.Dropdown(
        id='intervals-dropdown',
        options=[{'label': interval, 'value': interval} for interval in wells_df['MyIntervalPlus'].unique()],
        multi=True,
        placeholder="Select Intervals"
    ),
    dcc.Dropdown(
        id='pllintervals-dropdown',
        options=[{'label': interval, 'value': interval} for interval in wells_df['MyPerfInterval'].unique()],
        multi=True,
        placeholder="Select PLL Intervals"
    ),
    dcc.Dropdown(
        id='vintages-dropdown',
        options=[{'label': vintage, 'value': vintage} for vintage in wells_df['FirstProdYear'].unique()],
        multi=True,
        placeholder="Select Vintages"
    ),
    dcc.Graph(id='heatmap')
])

@app.callback(
    Output('heatmap', 'figure'),
    [Input('intervals-dropdown', 'value'),
     Input('pllintervals-dropdown', 'value'),
     Input('vintages-dropdown', 'value')]
)
def update_heatmap(selected_intervals, selected_pllintervals, selected_vintages):
    filtered_df = wells_df.copy()

    if selected_intervals:
        filtered_df = filtered_df[filtered_df['MyIntervalPlus'].isin(selected_intervals)]
    if selected_pllintervals:
        filtered_df = filtered_df[filtered_df['MyPerfInterval'].isin(selected_pllintervals)]
    if selected_vintages:
        filtered_df = filtered_df[filtered_df['FirstProdYear'].isin(selected_vintages)]
    
    heatmap_data = filtered_df.groupby(['MyIntervalPlus', 'MyPerfInterval', 'FirstProdYear']).size().reset_index(name='Counts')
    
    fig = px.density_heatmap(
        heatmap_data,
        x='MyIntervalPlus',
        y='FirstProdYear',
        z='Counts',
        color_continuous_scale='Viridis'
    )

    # Generate the HTML template
    html_template = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>Dynamic Map</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
        <style>
            html, body {{
                height: 100%;
                margin: 0;
            }}
            #map {{
                width: 100%;
                height: 100%;
            }}
            #controls {{
                position: absolute;
                top: 10px;
                left: 50px;
                z-index: 1000;
                background: white;
                padding: 10px;
                border-radius: 5px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            }}
            .legend {{
                position: absolute;
                top: 10px;
                right: 50px;
                z-index: 1000;
                background: white;
                padding: 10px;
                border-radius: 5px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            }}
        </style>
        <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
        <script src="https://d3js.org/d3.v5.min.js"></script>
    </head>
    <body>
        <div id="controls">
            <select id="layer-select" onchange="updateMap()">
                <optgroup label="Sections">
                    {''.join([f'<option value="1_{col}">{col}</option>' for col in avg_col_names])}
                </optgroup>
                <optgroup label="Townships">
                    {''.join([f'<option value="2_{col}">{col}</option>' for col in avg_col_names])}
                </optgroup>
            </select>
        </div>
        <div id="map"></div>
        <div class="legend" id="legend"></div>
        <script>
            var map = L.map('map').setView([{mean_latitude}, {mean_longitude}], 10);

            L.tileLayer('https://{{s}}.tile.openstreetmap.org/{{z}}/{{x}}/{{y}}.png', {{
                maxZoom: 18,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }}).addTo(map);

            var colormaps = {{}};
            var colormaps2 = {{}};

            {''.join([f"colormaps['{col}'] = d3.scaleThreshold().domain([30,60,90,120,150,180]).range(['white','blue', 'green', 'yellow', 'orange', 'red']);" for col in avg_col_names])}
            {''.join([f"colormaps2['{col}'] = d3.scaleThreshold().domain([30,60,90,120,150,180]).range(['white','blue', 'green', 'yellow', 'orange', 'red']);" for col in avg_col_names])}

            {''.join([f"""
            function style_{col}(feature) {{
                return {{
                    fillColor: colormaps['{col}'](feature.properties.{col}),
                    color: 'black',
                    weight: 0.5,
                    fillOpacity: 0.7
                }};
            }}
            """ for col in avg_col_names])}

            {''.join([f"""
            function style2_{col}(feature) {{
                return {{
                    fillColor: colormaps2['{col}'](feature.properties.{col}),
                    color: 'black',
                    weight: 0.5,
                    fillOpacity: 0.7
                }};
            }}
            """ for col in avg_col_names])}

            {''.join([f"""
            var layer_1_{col} = L.geoJson({geojson_data[col]}, {{
                style: style_{col},
                onEachFeature: function (feature, layer) {{
                    layer.bindPopup('EUR ({col.split('_')[1]} Months): ' + feature.properties.{col}.toFixed(2));
                }}
            }});
            window['layer_1_{col}'] = layer_1_{col};
            """ for col in avg_col_names])}

            {''.join([f"""
            var layer_2_{col} = L.geoJson({geojson_data2[col]}, {{
                style: style2_{col},
                onEachFeature: function (feature, layer) {{
                    layer.bindPopup('EUR ({col.split('_')[1]} Months): ' + feature.properties.{col}.toFixed(2));
                }}
            }});
            window['layer_2_{col}'] = layer_2_{col};
            """ for col in avg_col_names])}

            var currentLayer = window['layer_1_avg_6_months'];
            currentLayer.addTo(map);

            function updateMap() {{
                var selectedLayer = document.getElementById('layer-select').value;
                if (currentLayer) {{
                    map.removeLayer(currentLayer);
                }}
                currentLayer = window['layer_' + selectedLayer];
                if (currentLayer) {{
                    currentLayer.addTo(map);
                    var colormapSet = selectedLayer.startsWith("1_") ? colormaps : colormaps2;
                    updateLegend(colormaps[selectedLayer], [0,30,60,90,120,150]);
                }} else {{
                    console.error('Layer not found:', selectedLayer);
                }}
            }}

            function updateLegend(colormap, domain) {{
                var legend = d3.select('#legend');
                legend.html('<h4>EUR/PLL [BBL/FT]</h4>');
                var legendScale = d3.scaleLinear()
                    .domain([domain[0], domain[domain.length - 1]])
                    .range([0, 300]);
                var legendAxis = d3.axisBottom(legendScale)
                    .ticks(5)
                    .tickFormat(d3.format(".2f"));

                var svg = legend.append('svg')
                    .attr('width', 320)
                    .attr('height', 50);

                svg.append('g')
                    .attr('class', 'axis')
                    .attr('transform', 'translate(10,30)')
                    .call(legendAxis);

                var gradient = svg.append('defs')
                    .append('linearGradient')
                    .attr('id', 'gradient')
                    .attr('x1', '0%')
                    .attr('y1', '0%')
                    .attr('x2', '100%')
                    .attr('y2', '0%');

                domain.forEach(function(d, i) {{
                    gradient.append('stop')
                        .attr('offset', (i / (domain.length - 1) * 100) + '%')
                        .attr('stop-color', colormap(d));
                }});

                svg.append('rect')
                    .attr('width', 300)
                    .attr('height', 10)
                    .attr('x', 10)
                    .attr('y', 20)
                    .style('fill', 'url(#gradient)');
            }}

            updateLegend(colormaps['avg_6_months'], [0,30,60,90,120,150]);
        </script>
    </body>
    </html>
    """

    # Save the HTML template
    with open('dynamic_map.html', 'w') as f:
        f.write(html_template)

    print("HTML file created successfully: dynamic_map.html")

    return fig

if __name__ == '__main__':
    app.run_server(debug=True)
