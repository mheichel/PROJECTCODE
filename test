import pandas as pd
import geopandas as gpd
import numpy as np
from shapely.geometry import Point
import json

# Load the wells_df
columns = [
    'API 14', 'longitude', 'latitude',
    'EUR/PLL (BBL/FT) 6 Months', 'EUR/PLL (BBL/FT) 12 Months', 'EUR/PLL (BBL/FT) 18 Months',
    'EUR/PLL (BBL/FT) 24 Months', 'EUR/PLL (BBL/FT) 30 Months', 'EUR/PLL (BBL/FT) 36 Months',
    'EUR/PLL (BBL/FT) 42 Months', 'EUR/PLL (BBL/FT) 48 Months', 'EUR/PLL (BBL/FT) 54 Months',
    'EUR/PLL (BBL/FT) 60 Months', 'MyIntervalPlus', 'MyPerfInterval', 'FirstProdYear'
]

wells_df = pd.read_csv('AllWellsNoError.csv', usecols=columns)
wells_df = wells_df.rename(columns={'Surface Longitude': 'longitude', 'Surface Latitude': 'latitude'})
wells_df = wells_df[wells_df['latitude'] > 0.1]

for col in columns[3:13]:
    wells_df = wells_df[wells_df[col] > 0.1]
    wells_df = wells_df[wells_df[col] < np.nanpercentile(wells_df[col], 95)]

wells_df = wells_df.reset_index()

# Calculate mean latitude and longitude
mean_latitude = wells_df['latitude'].mean()
mean_longitude = wells_df['longitude'].mean()

# Convert well data to GeoDataFrame
geometry = [Point(xy) for xy in zip(wells_df['longitude'], wells_df['latitude'])]
geo_data = gpd.GeoDataFrame(wells_df, geometry=geometry)

# Set the CRS to WGS84 (EPSG:4326)
geo_data.set_crs(epsg=4326, inplace=True)

# Load the township boundaries shapefile
shape_data = gpd.read_file('PLSSFirstDivision.geojson')  # Replace with your shapefile path

# Ensure the CRS for the township boundaries is set to WGS84
shape_data.to_crs(epsg=4326, inplace=True)

# Spatial join to assign points to township polygons
joined = gpd.sjoin(geo_data, shape_data, how='left', op='within')

# Calculate average values for each township polygon
avg_col_names = []

for col in columns[3:13]:
    months = col.split()[2]
    avg_col_name = f'avg_{months}_months'
    shape_data[avg_col_name] = joined.groupby('index_right')[col].mean()
    avg_col_names.append(avg_col_name)

# Drop sections where all the average values are 0
shape_data = shape_data[(shape_data[avg_col_names] > 0).any(axis=1)]

# Create GeoJSON data for the first dataset
geojson1 = json.loads(shape_data.to_json())

# Load the second shapefile
shape_data2 = gpd.read_file('PLSSTownship.geojson')  # Replace with your second shapefile path
shape_data2.set_crs(epsg=4326, inplace=True)

# Spatial join to assign points to township polygons for the second shapefile
joined2 = gpd.sjoin(geo_data, shape_data2, how='left', op='within')

avg_col_names = []

for col in columns[3:13]:
    months = col.split()[2]
    avg_col_name = f'avg_{months}_months'
    shape_data2[avg_col_name] = joined2.groupby('index_right')[col].mean()
    avg_col_names.append(avg_col_name)

# Drop sections where all the average values are 0 for the second shapefile
shape_data2 = shape_data2[(shape_data2[avg_col_names] > 0).any(axis=1)]

# Create GeoJSON data for the second dataset
geojson2 = json.loads(shape_data2.to_json())

# Generate the HTML template
def generate_html_template(mean_latitude, mean_longitude, geojson1, geojson2):
    html_template = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>Dynamic Map</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
        <style>
            html, body {{
                height: 100%;
                margin: 0;
            }}
            #map {{
                width: 100%;
                height: 100%;
            }}
            #controls {{
                position: absolute;
                top: 10px;
                left: 50px;
                z-index: 1000;
                background: white;
                padding: 10px;
                border-radius: 5px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            }}
            .legend {{
                position: absolute;
                bottom: 30px;
                left: 50px;
                z-index: 1000;
                background: white;
                padding: 10px;
                border-radius: 5px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
                line-height: 18px;
                color: #555;
            }}
        </style>
        <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
        <script src="https://d3js.org/d3.v5.min.js"></script>
    </head>
    <body>
        <div id="controls">
            <select id="shapefile-select" onchange="updateMap()">
                <option value="geojson1">First Shapefile</option>
                <option value="geojson2">Second Shapefile</option>
            </select>
            <select id="intervals-select" multiple onchange="updateMap()">
                {''.join([f'<option value="{interval}">{interval}</option>' for interval in wells_df['MyIntervalPlus'].unique()])}
            </select>
            <select id="pllintervals-select" multiple onchange="updateMap()">
                {''.join([f'<option value="{interval}">{interval}</option>' for interval in wells_df['MyPerfInterval'].unique()])}
            </select>
            <select id="vintages-select" multiple onchange="updateMap()">
                {''.join([f'<option value="{vintage}">{vintage}</option>' for vintage in wells_df['FirstProdYear'].unique()])}
            </select>
        </div>
        <div id="map"></div>
        <div class="legend" id="legend"></div>
        <script>
            var map = L.map('map').setView([{mean_latitude}, {mean_longitude}], 10);

            L.tileLayer('https://{{s}}.tile.openstreetmap.org/{{z}}/{{x}}/{{y}}.png', {{
                maxZoom: 18,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }}).addTo(map);

            var geojson1 = {json.dumps(geojson1)};
            var geojson2 = {json.dumps(geojson2)};

            var currentLayer = L.geoJSON(geojson1, {{
                style: style,
                onEachFeature: onEachFeature
            }}).addTo(map);

            function getColor(d) {{
                return d > 150 ? '#800026' :
                       d > 100 ? '#BD0026' :
                       d > 50  ? '#E31A1C' :
                       d > 20  ? '#FC4E2A' :
                       d > 10  ? '#FD8D3C' :
                       d > 5   ? '#FEB24C' :
                       d > 0   ? '#FED976' :
                                '#FFEDA0';
            }}

            function style(feature) {{
                return {{
                    fillColor: getColor(feature.properties.avg_6_months),
                    weight: 2,
                    opacity: 1,
                    color: 'white',
                    dashArray: '3',
                    fillOpacity: 0.7
                }};
            }}

            function onEachFeature(feature, layer) {{
                layer.bindPopup('EUR/PLL (BBL/FT): ' + feature.properties.avg_6_months.toFixed(2));
            }}

            function updateLegend() {{
                var legend = d3.select('#legend').html('<h4>EUR/PLL (BBL/FT)</h4>');
                var grades = [0, 5, 10, 20, 50, 100, 150];
                var labels = [];
                for (var i = 0; i < grades.length; i++) {{
                    labels.push(
                        '<i style="background:' + getColor(grades[i] + 1) + '"></i> ' +
                        grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1] : '+')
                    );
                }}
                legend.html(labels.join('<br>'));
            }}

            updateLegend();

            function updateMap() {{
                var selectedShapefile = document.getElementById('shapefile-select').value;
                var selectedIntervals = Array.from(document.getElementById('intervals-select').selectedOptions).map(option => option.value);
                var selectedPLLIntervals = Array.from(document.getElementById('pllintervals-select').selectedOptions).map(option => option.value);
                var selectedVintages = Array.from(document.getElementById('vintages-select').selectedOptions).map(option => option.value);

                var geojsonData = selectedShapefile === 'geojson1' ? geojson1 : geojson2;
                var filteredFeatures = geojsonData.features.filter(feature => {{
                    var properties = feature.properties;
                    return (selectedIntervals.length === 0 || selectedIntervals.includes(properties.MyIntervalPlus)) &&
                           (selectedPLLIntervals.length === 0 || selectedPLLIntervals.includes(properties.MyPerfInterval)) &&
                           (selectedVintages.length === 0 || selectedVintages.includes(properties.FirstProdYear));
                }});

                if (currentLayer) {{
                    map.removeLayer(currentLayer);
                }}
                currentLayer = L.geoJSON({{'type': 'FeatureCollection', 'features': filteredFeatures}}, {{
                    style: style,
                    onEachFeature: onEachFeature
                }}).addTo(map);
                updateLegend();
            }}
        </script>
    </body>
    </html>
    """

    with open('dynamic_map.html', 'w') as f:
        f.write(html_template)

    print("HTML file created successfully: dynamic_map.html")

generate_html_template(mean_latitude, mean_longitude, geojson1, geojson2)
